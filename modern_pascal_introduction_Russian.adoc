# Краткое введение в современный Object Pascal для программистов
Michalis Kamburelis
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: coderay
:docinfo1:

## Для чего это нужно?

Существует множество книг и источников о Паскале, но слишком много из них говорят о старом Паскале, без классов, модулей, дженериков (generics).
// Some of them talk about Pascal before it even had classes. Some of them show classes, as done in Delphi, but fail to mention more modern features, like generics.

Поэтому я написал это краткое введение о том , что я называю *современным Object Pascal*. Большинство программистов используют его, действительно не называя так _"современный Object Pascal"_, мы просто называем  _"наш Pascal"_.
 Но представляя язык, я считаю важным подчеркнуть, что это современный, объектно-ориентированный язык. Он был *существенно* усовершенствован по сравнению со старым (Turbo) Pascal, который когда-то давно изучали в школах. Сегодня его можно вполне сравнивать C++, Java или C#.

* Он имеет все современные особенности, которые можно ожидать — классы, модули, интерфейсы, дженерики...
* Он компилируется в быстрый машинный код,
* Он очень типобезопасен,
* Высокоуровневый, но может быть низкоуровневым если это необходимо.

Он так же имеет превосходных, портативный компиляторов с открытым кодом названным _Free Pascal Compiler_, http://freepascal.org/ . И сопровождаемая IDE (редактор, отладчик, библиотека компонентов, создатель форм), названная _Lazarus_ http://lazarus.freepascal.org/ . Я являюсь создателем _Castle Game Engine_, http://castle-engine.sourceforge.net/ , является крутым портативным двух и трёхмерным игровым движком, использующим этот язык, чтобы создавать игры для многих платформ (Windows, Linux, MacOSX, Android, iOS, web плагины).

Это введение больше направлено на программистов, которые уже имеют опыт в других языках. Мы не будем раскрывать здесь значения некоторых универсальных концепций, как _"что такое класс"_, мы только покажем как они реализуются в Pascal.

## Основы

### Программа "Hello world"

[source,pascal]
----
include::code-samples/hello_world.lpr[]
----

Это полноценная программа, которую можно _скомпилировать_ и _запустить_.

* Если используется командная строка FPC, достаточно просто создать новый файл `myprogram.lpr` и выполнить команду `fpc myprogram.lpr`
* Если используется _Lazarus_, то необходимо создать новый проект (в строке меню: _Project_ -> _New Project_ -> _Simple Program_). Сохраните его как `myprogram` и вставьте в него этот исходный код. Компиляция выполняется используя пункт _Run_ → _Compile_ в меню.
* Эта консольная программа, так что, в обоих случаях, -- скомпилированный исполняемый файл нужно запустить из терминала командной строки, чтобы увидеть результат.

Остальная часть этой статьи рассказывает о самом языке Object Pascal, поэтому не ожидайте чего-нибудь большего, чем приложений командной строки. Если хочется взглянуть на что-либо более "крутое", можно просто создать новый GUI проект в _Lazarus_ (_Project_ -> _New Project_ -> _Application_).
//Play around, drop some buttons on the form, handle their events (like `OnClick`).
Вуаля! -- рабочее кроссплатформенное GUI приложение, с нативным видом, использующее удобные визуальные библиотеки. _Lazarus_ и _Free Pascal Compiler_ имеют множество готовых компонент для сетей, GUI, баз данных, чтения и записи различных форматов файлов (XML, json, изображения...), управления потоками и всем, что только может понадобиться программисту. Ярким тому примером является крутой _Castle Game Engine_, о котором упоминалось ранее:)
// The libraries created in other languages (dll, so, dylib) can be easily used from FPC too (and for most of them, you'll find ready "header" units, and even units that wrap them in more modern object-oriented API).

### Функции, процедуры, простейшие типы

[source,pascal]
----
include::code-samples/functions_primitives.lpr[]
----

Чтобы вернуть значение функции, присвой что-нибудь магическое переменной `Result`. Можно свободно читать и устанавливать переменную `Result`, так же просто как локальную переменную.

[source,pascal]
----
function MyFunction(const S: string): string;
begin
  Result := S + 'что-нибудь';
  Result := Result + ' ещё что-нибудь!';
  Result := Result + ' И ещё немножко!';
end;
----

Можно рассматривать имя функции (как `MyFunction` в примере выше) как переменную, которой можно присвоить значение и использовать как обычную переменную. Но я бы препятствовал этому в новом коде, так как это выгладит "тусклым/подозрительным" когда использовано на правой стороне присваиваемого выражение. Просто используй `Result` всегда, когда нужно использовать или устанавливать значение функции.

Если необходимо вызвать функцию рекурсивно, ты кончено можешь сделать это, но не забудь указать специальные параметры (такой рекурсивный вызов с параметром получает другой результат в отличии от резульата доступа к текущему результату функции). Так:
[source,pascal]
----
function ReadIntegersUntilZero: string;
var
  I: Integer;
begin
  Readln(I);
  Result := IntToStr(I);
  if I <> 0 then
    Result := Result + ' ' + ReadIntegersUntilZero();
end;
----

Можно вызвать `Exit`, чтобы окончить выполнение процедуры или функции до того, как она достигнет завершающего `end;`. Если вызвать без параметров `Exit` в функции, она вернёт последнее значение, присвоеное `Result`. Так же можно использовать конструкцию `Exit(X)`, чтобы установить результат функции и выйти *сейчас* — это тоже что и `return X` конструкция в С-подобных языках.

[source,pascal]
----
function AddName(const ExistingNames, NewName: string): string;
begin
  if ExistingNames = '' then
    Exit(NewName);
  Result := ExistingNames + ', ' + NewName;
end;
----

### Условные операторы (if)

Конструкции `if .. then` или `if .. then .. else` запускают некий код, когда некое условие удовлетворительно. В отличии от C-подобных языков, в Pascal нет необходимости ставить условие в скобки.

[source,pascal]
----
var
  A: Integer;
  B: boolean;
begin
  if A > 0 then
    DoSomething;

  if A > 0 then
  begin
    DoSomething;
    AndDoSomethingMore;
  end;

  if A > 10 then
    DoSomething
  else
    DoSomethingElse;

  // идентично предыдущему примеру
  B := A > 10;
  if B then
    DoSomething
  else
    DoSomethingElse;
end;
----

Оператор `else` относится к последнему условию `if`. Поэтому оно работает, как и ожидается:

[source,pascal]
----
if A <> 0 then
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
----

Обертывание вложения `if` внутри `begin ... end` часто лучше, чем предыдущий пример. Оно более очевидно читателю, даже если ты перемешаешь, испортишь отступы. И когда ты добавляешь / удаляешь некий `else` пункт в коде ниже, оно очевидно к какому условию оно применяется (A тестируется или B тестируется), поэтому оно мене подвержено ошибкам.

[source,pascal]
----
if A <> 0 then
begin
  if B <> 0 then
    AIsNonzeroAndBToo
  else
    AIsNonzeroButBIsZero;
end;
----

### Логические операторы, операторы отношений и побитовые (поразрядные) операторы

_Логические операторы_ - это `and`, `or`, `not`, `xor`. Их значение, вероятно, очевидно (разве что, за исключением оператора `xor`, который в русской литературе обычно называется _"исключающее или"_). Они берут _булевские аргументы (boolean)_, и возвращают также значение типа _boolean_. Они так же могут работать как _побитовые операторы_, когда оба аргумента целого типа (integer, byte или другие), в этом случае они также возвращают значение идентичного целого типа.

_Операторы отношения (сравнения)_ - представлены очевидными комбинациями символов: `=`, `<>`, `>`, `<`, `\<=`, `>=`. Следует отметить, что в отличии от синтаксиса С-подобных языков, в Паскале оператор сравнения идентичности выглядит как один знак "равно" `A = B` (в отличии от С, где используется код `A == B`). Специальным _оператором присваивания_ в паскале является `:=`.

_Логический (или побитовый) оператор имеет более высокий приоритет, чем операторы отношения_. Поэтому может понадобиться использовать круглые скобки вокруг сравниваемых выражений.

Следующий пример вызовет ошибку компиляции:

[source,pascal]
----
var
  A, B: Integer;
begin
  if A = 0 and B <> 0 then ... // так делать НЕЛЬЗЯ
----

Ошибка связана с тем, что компилятор пытается в первую очередь пытается выполнить побитовый оператор `and` в середине выражения и в результате получается `(0 and B)`, которое возвращает целочисленную величину. Далее компиллятор выполняет оператор "равно" и получает булевскую величину `A = (0 and B)`. Финальная ошибка оказывается связана с попыткой сравнить булевскую величину `A = (0 and B)` с целочисленной величиной `0`.

Правильно будет делать следующим образом:

[source,pascal]
----
var
  A, B: Integer;
begin
  if (A = 0) and (B <> 0) then ...
----

Паскаль использует _"короткую оценку (short-circuit evaluation)"_ - оптимизацию, которая позволяет не рассчитывать выражение целиком, если его первая часть определяет результат. Рассмотрим пример:

[source,pascal]
----
if MyFunction(X) and MyOtherFunction(Y) then...
----

* Значение функции `MyFunction(X)` всегда рассчитывается первым.
* И если `MyFunction(X)` вернёт значение `false`, это означает, что мы уже знаем результат всего выражения (Какое бы ни было второе значение при выполнении `false and что-нибудь` мы всегда получим `false`). Таким образом `MyOtherFunction(Y)` вообще не будет выполняться.
* Идентичная ситуация и с выражением `or`. В данном случае, если мы наперёд знаем, что результат будет `true` потому что первый аргумент имеет значение `true`, второй аргумент не влияет на результат и вообще не рассчитывается.
* Это особенно полезно если нужно записать выражение типа:
+
[source,pascal]
----
if (A <> nil) and A.IsValid then...
----
+
Здесь не возникнет ошибки даже в случае если `A` имеет значение `nil` (т.е. нулевой указатель).

// * Using `and` between two boolean values is a logical `and`, and the result is boolean. In other words, the result is `true` only if both operands are `true`, otherwise it's `false`.

// * Using `and` between two integer values is a bit-wise `and`, and the result is integer. The operands are converted to have the same number of bits, and a similar rule is performed bit-by-bit, setting each bit to `0` or `1`. If you do this with potentially negative integer values, you should understand how negative numbers are encoded in memory (_"two's complement"_).

### Проверка одного выражения на множественные значения (оператор case)

Если в зависимости от разных значений переменной должны быть исполнены разные действия, тогда может оказаться полезной конструкция `case .. of .. end`.

[source,pascal]
----
case SomeValue of
  0: DoSomething;
  1: DoSomethingElse;
  2: begin
       IfItsTwoThenDoThis;
       AndAlsoDoThis;
     end;
  3..10: DoSomethingInCaseItsInThisRange;
  11, 21, 31: AndDoSomethingForTheseSpecialValues;
  else DoSomethingInCaseOfUnexpectedValue;
end;
----

Условие `else` опционально. Если текущее значение анализируемого выражения не совпадает ни с одним из описанных случаев и нет условия `else`, то программа просто пропустит всю конструкцию и будет выполняться дальше.

Программистам С-подобных языков полезно сравнить `case` с подобной конструкцией `switch` в этих языках. Стоит отметить, что `case` в Паскале защищён от случайного выполнения следующей инструкции. Нет необходимости помнить каждый раз размещать инструкцию `break` в конце каждого блока. После выполнения ветви условия программа автоматически закончит обработку конструкции `case` и продолжит выполнение дальше.

### Перечисляемый и порядковый типы, наборы и массивы постоянной длины

Перечисляемый тип в паскале очень аккуратный и комфортный. Возможно, Вы будете использовать его чаще чем перечисляемые типы в других языках:)

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
----

Общепринято, что префикс перечисляемого типа состоит из двух букв сокращения имени типа, следовательно `ak` = сокращение для _"Animal Kind"_. Это полезное соглашение, так как имена перечисляемых типов находятся в глобальном пространстве модуля. Так с помощью префикса `ak`, автоматически уменьшаются шансы на конфликт с другими идентификаторами.

ПРИМЕЧАНИЕ: Конфликты в именах не приводят к неработоспособности программы. Это вполне допустимо в различных модулях определять одинаковые идентификаторы. Но хорошей идеей будет попытка избежать столкновений в любом случае, чтобы код был прост в понимании и анализа. 

ПРИМЕЧАНИЕ: Можно избежать помещения имён перечисляемых типов в глобальное пространство с помощью директивы компиллятора `{$scopedenums on}`. Это значит, будет необходимо обращаться к ним с помощью обращения к имени типа, как `TAnimalKind.akDuck`. В таком случае необходимость в префиксе `ak` исчезает, и можно будет просто оставить названия `Duck, Cat, Dog`. Это похоже на перечисляемые списки C#. 

Факт того, что перечисляемый тип _комфортен_ т.е. не может быть просто присвоен к целому и присвоен из целого. Тем не менее, для специального использования, можно использовать `Ord(MyAnimalKind)`, чтобы насильно привести список к целому типу, или дать подходящую роль `TAnimalKind(MyInteger)` чтобы конвертировать integer к перечисляемому типу. В последнем случае, проверь является ли `MyInteger` частью диапазона `(0 to Ord(High(TAnimalKind)))`.

Перечисляемые и порядковые типы могут быть использованы как индексы массива:

[source,pascal]
----
type
  TArrayOfTenStrings = array [0..9] of string;
  TArrayOfTenStrings1Based = array [1..10] of string;

  TMyNumber = 0..9;
  TAlsoArrayOfTenStrings = array [TMyNumber] of string;

  TAnimalKind = (akDuck, akCat, akDog);
  TAnimalNames = array [TAnimalKind] of string;
----

Они так же могут быть использованы для создания наборов(внутренне битовое поле):

[source,pascal]
----
type
  TAnimalKind = (akDuck, akCat, akDog);
  TAnimals = set of TAnimalKind;
var
  A: TAnimals;
begin
  A := [];
  A := [akDuck, akCat];
  A := A + [akDog];
  A := A * [akCat, akDog];
  Include(A, akDuck);
  Exclude(A, akDuck);
end;
----

### Циклы (for, while, repeat, for .. in)

[source,pascal]
----
include::code-samples/loops.lpr[]
----

Примечания:

* Может казаться, что различие между `while` и `repeat` циклами лишь "косметические" и лишь условие записано условие "с точностью до наоборот", в случае `while .. do` выполнение _продолжается_, пока условие _истино_, а в `repeat .. until` - выполнение _прекращается_, когда условие _выполняется_. Однако есть ещё одно важное отличие: в случае `repeat`, _условие проверяется не в начале, а в конце_. Поэтому цикл `repeat` всегда выполняется как минимум один раз.

* Конструкция `for I := .. to .. do ...` похожа на C-подобный цикл `for`. Тем не менее, она более ограничено, как вы не можете указать произвольное действие/тесты чтобы контролировать итерации цикла. В Паскале for используется строго для итерации через последовательные числа (или другие порядковые типы). Единственной уступкой является использование `downto` вместо `to`, чтобы производить счёт в обратном порядке.
+
С другой стороны, это существенно легче для понимания, и лучше для оптимизации в исполнении. Например, _значения верхней и нижней границы вычисляется один раз_, до начала исполнения цикла.
+
Следует также обратить внимание, что переменная, которая использовалась для цикла (в примере выше - `I`) становится неопределённой после окончания цикла кроме случая досрочного выхода из цикла с помощью команд `Break` или `Exit`.
*Цикл for `I in .. do ..` такой же как конструкция foreach в многих современных языках. Он хорошо понимает организацию всех встроенных типов:
** Он может перебирать все значения массива (см. пример выше).
** Он может перебирать все возможные значения перечисляемого типа:
+
[source,pascal]
----
var
  AK: TAnimalKind;
begin
  for AnimalKind in TAnimalKind do...
----

** Он может перебирать все элементы набора:
+
[source,pascal]
----
var
  Animals: TAnimals;
  AK: AnimalKind;
begin
  Animals := [akDog, akCat];
  for AK in Animals do ...
----

** И так же работает на всех пользовательких/кастомных типах, включая дженерики, например, `TObjectList` или `TFPGObjectList`.
+
[source,pascal]
----
include::code-samples/for_in_list.lpr[]
----
+
Мы еще не рассматривали концепцию классов, поэтому последний пример может показаться неочевидным, но мы обязательно рассмотрим этот вопрос чуть позже :)

### Вывод информации и логов

Чтобы просто вывести строки в Паскале используй процедуру `Write` или `Writeln`. Во втором случае в конце автоматически добавляется перенос строки.

Это "волшебная" процедура в Паскале, Она принимает переменное число аргументов, которые могут иметь любой тип. Они все будут приведены к строке при выводе, также можно добавить специальный синтаксис для указания как отформатировать число.

[source,pascal]
----
Writeln('Hello world!');
Writeln('Можно вывести целое число: ', 3 * 4);
Writeln('Отформатировать его: ', 666:10);
Writeln('А также вывести число с плавающей запятой: ', Pi:1:4);
----
Чтобы явно завершить строку можно использовать константу `LineEnding` constant (из FPC RTL). (_Castle Game Engine_ имеет также более краткий вариант `NL`). В отличии от HTML и других подобных разметок в паскалевских строках обратная косая (`\`) не позволяет вставлять специальные символы. По этому:

[source,pascal]
----
Writeln('Первая строка.\nВторая стока.'); // НЕВЕРНЫЙ пример
----

не будет работать так, как можно было бы предположить. Правильно делать следующим образом:

[source,pascal]
----
Writeln('Первая строка.' + LineEnding + 'Вторая строка.');
----

или так:

[source,pascal]
----
Writeln('Первая строка.');
Writeln('Вторая строка.');
----

Стоит отметить, что это будет работать только в _консольных_ приложениях. Для этого нужно указывать `{$apptype CONSOLE}` (*но не* `{$apptype GUI}`) в главном файле программы. На некоторых ОС консоль явно или скрыто присутствует всегда (Unix) и этот параметр не используется, но в некоторых системах попытка выполнения `write`/`writeln` из GUI приложения может привести к ошибке (например, в Windows).

В *Castle Game Engine:* категорически не советуется пользоваться `Writeln`, для этого есть специальная функция `WritelnLog` или `WritelnWarning` для вывода логов и отладочной информации, при этом. Их результат всегда будет направлен в полезном направлении: для Unix это будет стандартный вывод в консоль. Для Windows GUI приложений это будет лог-файл. В Android будет отображаться _Android logging facility_ (инструмент логов Андроида) (который можно просматривать с помощью команды `adb logcat`). Использовать `Writeln` есть смысл лишь в ограниченном наборе случаев, например, для консольных приложений (исполняемых из командной строки) и можно быть точно уверенным, что _стандартный вывод_ определён. Например, так можно делать в конвертере или генераторе трёхмерных моделей, который выполняется из командной строки.

### Преобразование данных в строчный тип

Для преобразования произвольного количества аргументов в строку (вместо того, чтобы напрямую выводить их) есть несколько возможных подходов.

* Некоторые конкретные типы можно преобразовать в строку используя специальные функции, такие как `IntToStr` и `FloatToStr`. В дальнейшем совмещать (concatenate) строки в Паскале возможно просто используя знак сложения. Таким образом можно создавать составные строки: `'Моё целое число ' + IntToStr(MyInt) + ', а значение числа пи составляет ' + FloatToStr(Pi)`.
** _Преимущество_: Это очень удобно. Существует множество функций типа `XxxToStr` и им подобных (например, `FormatFloat`), для множества различных типов данных.
// They give you a lot of flexibility in formatting.
** _Второе преимущество_: Имеют пару обратных функций. Чтобы преобразовать строку (например, введённую пользователем) обратно в целое или дробное число можно использовать `StrToInt`, `StrToFloat` и подобные (например, `StrToIntDef`).
** _Недостаток_: Длинная сумма (concatenation) множества `XxxToStr` и строк выглядит некрасиво.
//For classes, they can override the `TObject.ToString` method.
//It doesn't have that clean _separation of pattern and arguments_ property of `Format` call.

* Функция `Format` используется в виде `Format('%d %f %s', [MyInt, MyFloat, MyString])`. Она подобна функции `sprintf` в си-подобных языках. Она вставляет аргументы в соответствующие placeholder-ы согласно заданному образцу. Эти placeholder-ы могут использовать специальный синтаксис, влияющий на форматирование, например `%.4f` это дробный формат с 4 знаками после запятой.
** _Преимущество_: Отделение _строки_ от _аргументов_ выглядит чисто. Легко изменить текст строки, не изменяя аргументов (например, если необходимо выполнить перевод).
** _Второе преимущество_: No compiler magic. You can use the same syntax to pass any number of arguments of an arbitrary type in your own routines (определите параметр как `array of const`). Затем Вы можете передать эти аргуметы функции `Format`, или деконструировать список параметров и делать с ним всё, что угодно.
** _Недостаток_: Копиллятор не проверяет, соответствует ли строка-образец аргументам. Используя неверный тип placeholder-а приведёт к ошибке `EConvertError` exception, впрочем гораздо более понятной, чем segmentation fault.
//Note that, unlike the C `sprintf`, the correctness at runtime can be completely verified (there are no dirty pointer tricks inside

* Функция `WriteStr(TargetString, ...)` во многом подобна базовой функции `Write(...)`, с одним отличием - результат сохраняется в `TargetString`.
** _Преимущество_: Имеет все возможности функции `Write`, в том числе и специальный синтаксис для форматирования, как например `Pi:1:4`.
** _Недостаток_: Такой специальный синтаксис для форматирования является "compiler magic", написанный специально для конкретной процедуры. Часто это приводит к проблемам, например, невозможно создать свою функцию `MyStringFormatter(...)` которая бы принимала такой синтасис, как `Pi:1:4`. Именно по этому, а также из-за того, что эта функция долгое время не была доступна в основных компилляторах, такая конструкция не очень популярна.

## Модули (Units)

Модули позволяют группировать общие функции и объекты (всё, что может быть объявлено), для использования другими модулями и программами. Они эквивалентны _модулям_ и _пакетам_ в других языках. Они имеют секцию интерфейса, где объявляются доступные для других модулей и программ переменные, функции и т.п., секцию их реализации, где описано, как они работают. Модуль `MyUnit` можно сохранить под именем `myunit.pas` (название должно быть без заглавных букв с расширением `.pas`).

[source,pascal]
----
include::code-samples/myunit.pas[]
----

Финальная программа сохраняются в виде файлов типа `myprogram.lpr` (`lpr` = Lazarus program file; в Delphi используются `.dpr`). Следует отметить, что возможны и другие расширения, например, некоторые проекты просто используют `.pas` в качестве основного файла программы, изредка для модулей используются расширения `.pp`. Лично я предпочитаю использовать `.pas` для модулей и `.lpr` для FPC/Lazarus программ.

Программа может подключать модуль с помощью ключевого слова `uses`:

[source,pascal]
----
include::code-samples/myunit_test.lpr[]
----

### Перекрёстные ссылки между модулями

Не только основная программа, но и модули также могут ссылаться на другие модули. Другой модуль может войти в секцию interface или только в implementation. Первый вариант позволяет создавать новые определения (процедуры, типы...), используя или наследуя информацию из другого модуля. Во втором варианте возможности более ограничены, если использовать модуль в секции implementation, то применить его идентификаторы возможно лишь в рамках implementation данного модуля.

[source,pascal]
----
include::code-samples/anotherunit.pas[]
----

Запрещено применять _кольцевую взаимозависимость_ в разделе interface.  Т.е. два модуля не могут использовать друг друга в разделе interface.
//that everything must be declared before it's used.
Причина такого ограничения заключается в том, чтобы "понять"
//(e.g. determine the memory layout of all the structures)
секцию interface модуля, компилятор анализирует и "понимает" все модули, перечисленные в uses в секции interface.
В Паскале это правило придерживается строго, что позволяет достичь высокой скорости компилляции и полностью автоматическое определение компиллятором _что же именно необходимо перекомпилировать_. В Паскале нет необходимости создания сложных ``Makefile`` для выполнения простой задачи компилляции, а также нет нужды _перекомпилировать всё_ лишь для того, чтобы быть уверенным, что все зависимости правильно обновились.
//, but also makes circular dependencies _between units interfaces_ impossible.
//(That said, this constraint is not existing in some other languages. You can actually do parsing without "complete understanding" of your dependencies, just some stuff will have to be resolved later, e.g. at linking. You can also "repeat" the compilation until your knowledge is "settled". Anyway, you have to live with this constraint now, and enjoy fast compilation times.:)

Вполне возможно создавать кольцевые зависимости между модулями когда один из них "используется" только в implementation. Поэтому нормально для `A` использовать `B` в interface, и затем модуль `B` использует `A` в implementation.

### Определение идентификаторов с именем модуля

Различные модули могут определять одинаковые идентификаторы. Чтобы поддерживать код простым для чтения и поиска, обычно следует избегать таких совпадений, но это не всегда возможно. В таких случаях, последний модуль в списке `uses` "перетягивает одеяло на себя", т.е. идентификаторы определенные в нём скрывают одноимённые идетификаторы вводимые другими модулями ранее.
// in some situations (e.g. when you use a third-party library).

Возможно всегда недвусмысленно определить модуль дающего идентификатор, используя как `MyUnit.MyIdentifier`. Это обычное решение когда используемый идентификатор из `MyUnit` скрыт в другом модуле. Таким же образом можно перестроить порядок модулей в списке uses, хотя это может повлиять не только на исправляемые идентификаторы, но и на другие.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
program showcolor;

// Модули Graphics и GoogleMapsEngine определяют свой тип TColor.
uses Graphics, GoogleMapsEngine;

var
  { Это сработает не так, как ожидается, поскольку TColor
    определяется последним модулем в списке - GoogleMapsEngine. }
  // Color: TColor;
  { А так будет правильно. }
  Color: Graphics.TColor;
begin
  Color := clYellow;
  Writeln(Red(Color), ' ', Green(Color), ' ', Blue(Color));
end.
----

В случае модулей следует также опмнить, что они могут иметь два списка `uses`: один - в секции `interface`, другой - в `implementation`. Правило - _Позднейшие модули скрывают все что было делают предыдущие модули_ и применяется последовательно, что означает, что _модули использованые в секции implementation_ могут скрывать идентификаторы из _модулей использованных в секции interface_. Тем не менее не стоит забывать, что в процессе чтения секции interface компилятором, только модули использованные в секции interface имеют значение. Это может сбить с толку в ситуациях, когда два на вид одинаковых объявления обрабатываются по-разному компилятором:

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// НЕВЕРНЫЙ пример

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

Модуль `Graphics` (из набора библиотек Lazarus LCL) определяет тип `TColor`. Но компилятор указывает на ошибку в этом модуле, заявляя что заявленная в секции Interface процедура `ShowColor` не описана. Проблема в том, что модуль `GoogleMapsEngine` так же определяет тип `TColor`, который используется только в секции `implementation`, следовательно оно _перекрывает_ определение `TColor` только в секции implementation. Т.е. компилятор видит это буквально как:


[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

// НЕВЕРНЫЙ пример
// демонстрирующий, как предыдущий пример "видит" компилятор

interface

uses Graphics;

procedure ShowColor(const Color: Graphics.TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: GoogleMapsEngine.TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

Решение в данном случае - тривиальное, нужно просто изменить implementation, чтобы явно использовать `TColor` из модуля `Graphics`. Это также можно исправить, переметив подключение модуля `GoogleMapsEngine` в секцию interface до модуля `Graphics`. Впрочем, это может привести к последствиям внутри модуля `UnitUsingColors` и коснётся всех его определений.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit UnitUsingColors;

interface

uses Graphics;

procedure ShowColor(const Color: TColor);

implementation

uses GoogleMapsEngine;

procedure ShowColor(const Color: Graphics.TColor);
begin
  // Writeln(ColorToString(Color));
end;

end.
----

### Использование идентификаторов одного модуля в другом

Иногда возникает необходимость взять идентификатор из одного модуля, и _использовать_ либо _изменять_ его в другом модуле. Результатом должно быть тем, что использование нового модуля делает идентификатор доступным в пространстве имён.

Иногда подобные манипуляции необходимы для сохранения совместимости с предыдущими версиями версиями модуля. Иногда неплохо "скрыть" внутренний unit в данной ситуации.

Это может быть осуществлено с помощью переопределения идетификатора в новом модуле.

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit MyUnit;

interface

uses Graphics;

type
  { Использовать TColor из модуля Graphics для определения TMyColor. }
  TMyColor = TColor;

  { Как вариант, можно переопределить его под тем же именем.
    В таком варианте необходимо будет указать нименование модуля, иначе
    получится несогласованное определение "TColor = TColor". }
  TColor = Graphics.TColor;

const
  { С константами это тоже работает. }
  clYellow = Graphics.clYellow;
  clBlue = Graphics.clBlue;

implementation

end.
----

Стоит отметить, что данный трюк не пройдёт с глобальными процедурами, функциями и переменными. С ними необходимо объявить постоянный указатель на процедуру в другом модуле (см. <<Callbacks>>), но такой код выглядит не совсем чисто.

Обычным решением является создание тривиальной "функции-обертки", которая под видом простого вызова функции из внешнего модуля, просто передаёт ему параметры и возвращает принимаемые значения обратно.

Чтобы проделать тоже с глобальными параметрами иногда используются глобальные (unit-level) свойства, см. <<Properties>>.

## Классы (Classes)

### Основы

В Pascal для объектно-ориентированного программирования чаще всего используются классы (classes). На базовом уровне класс просто является контейнером для

* _поля (field)_ (удобное имя для _"переменной внутри класса"_),
* _методы (method)_ (удобное имя для _"a процедуры или функции внутри класса"_),
* и _свойства (property)_ (удобный синтаксис для конструкции подобной полю, однако в действительности являющейся парой методов, используемых для _чтения (get)_ и _записи (set)_ чего-либо; детальнее см. <<Properties>>).
* Вообще говоря в классах можно разместить <<More stuff inside classes and nested classes>>, но об этом пойдёт речь чуть позже.

[source,pascal]
----
type
  TMyClass = class
    MyInt: Integer;
    procedure MyMethod;
  end;

procedure TMyClass.MyMethod;
begin
  Writeln(MyInt + 10);
end;
----

### Наследование (Inheritance), проверка (is), и приведение типов (as)

Паскаль поддерживает наследование и виртуальные методы ООП.

[source,pascal]
----
include::code-samples/inheritance.lpr[]
----

По умолчанию методы являются виртуальными, чтобы сделать их такими, необходимо использовать специальное ключевое слово `virtual`. Перекрытие или замещение виртуального метода осуществляется с помощью ключевого слова `override`, в ином случае будет ошибка. Чтобы скрыть метод без перекрытия следует использовать ключевое слово `reintroduce`, однако обычно не стоит так делать кроме случаев, когда для этого есть особые причины.

Чтобы узнать, является ли класс из семейства классов конкретным его экземпляром можно использовать оператор `is`. Для выполнения приведения типа класса к конкретному экземпляру следует использовать оператор `as`.

[source,pascal]
----
include::code-samples/is_as.lpr[]
----

Вместо приведения типа `X as TMyClass`, можно также использовать приведение типа _без проверки_ с помощью выражения типа `TMyClass(X)`. Такой код будет работать чуть-чуть быстрее, но может привести к неопределённому поведению в случае если  `X` не является наследником `TMyClass`. По этому конструкцию `TMyClass(X)` лучше не использовать в программе кроме случаев, когда абсолютно очевидно, что здесь не может быть ошибок, например, если тип класса был проверен с помощью оператора `is`:

[source,pascal]
----
if A is TMyClass then
  (A as TMyClass).CallSomeMethodOfMyClass;
// вариант ниже - работает незначительно быстрее
if A is TMyClass then
  TMyClass(A).CallSomeMethodOfMyClass;
----
### Свойства (Properties)

Свойства (Properties) являются _"синтаксическим сахаром" (syntax sugar - жаргон, означающий синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для программиста)_ который можно использовать с целью:

1. Сделать что-то внешнее похожее на поле (может быть прочитано и установлено) но ниже реализовано вызовом функциями _считывания значения (getter)_ и _установки значения (setter)_. Самое обычное применение такого подхода - выполннение дополнительных действий каждый раз, когда некоторое значение изменяется.
2. Сделать что-то внешне похожее на поле, но только доступное для чтения. В результате, это что-то вроде константы или функции без параметров.

[source,pascal]
----
type
  TWebPage = class
  private
    FURL: string;
    FColor: TColor;
    function SetColor(const Value: TColor);
  public
    { Невозможно напрямую установить.
      Следует вызвать метод вроде Load('http://www.freepascal.org/'),
      для загрузки страницы и установки значения этого свойства. }
    property URL: string read FURL;
    procedure Load(const AnURL: string);
    property Color: TColor read FColor write SetColor;
  end;

procedure TWebPage.Load(const AnURL: string);
begin
  FURL := AnURL;
  NetworkingComponent.LoadWebPage(AnURL);
end;

function TWebPage.SetColor(const Value: TColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    // Например, требовать обновления, каждый раз когда это значение изменяется
    Repaint;
    // Ещё пример: обеспечить чтобы нечто изменялось синхронно
    // с установкой цвета, например
    RenderingComponent.Color := Value;
  end;
end;
----

// { compare with the old value, to shield from making
//   useless assignments to RenderingComponent.Color.
//   This is a common approach to guarantee that setting WebPage.Color
//   many times to the same value will be fast,
//   even if setting RenderingComponent.Color many times to the same value
//   would be slow. }

Стоит обратить внимание, что вместо того, чтобы указать method, Вы можете также указать поле (field) (которое обычно является private) чтобы просто напрямую получать или устанавливать значение. В примере выше, свойство `Color` использует  _setter_-метод `SetColor`. Однако, для получения значения свойство `Color` напрямую ссылается на private field `FColor`. Прямая ссылка на конкретное field быстрее, чем написание дополнительных методов getter или setter - как с точки зрения разработки, так и с точки зрения исполнения программы.

При объявлении свойства указывается:

. может ли оно быть прочитано, и как (с помощью прямого чтения поля, или с использованием метода `getter`).
. может ли оно быть установлено, и как (с помощью прямой записи поля, или вызовом метода `setter`).

Компилятор следит за тем, чтобы типы и параметры соответствующих полей и методов совпадали с типом свойства с которым они работают. Например, чтобы прочитать свойство `Integer` следует или предоставить поле `Integer`, или беспараметрический метод (функцию), который возвращает `Integer`.

С технической точки зрения, для компилятора, методы "getter" и "setter"  - обычные методы и они могут делать абсолютно что угодно (включая массу дополнительных функций). Но правилом хорошего тона является создавать такие свойства, которые ведут себя более-менее подобно обычному полю:

// There are some good conventions to follow when creating properties. These are only conventions, the compiler doesn't prevent you from making something weird using properties -- f. But the good
// They should be somewhat predictable, like fields:

* Функция _getter_ не должна иметь видимые побочные эффекты (например, она не должна читать некоторый ввод из файла / клавиатуры). Её значение должно быть детерменистическим (без рандомизации или псевдо-рандомизации :)) Чтение свойства каждый раз должно иметь смысл и возвращать одинаковый результат, если между операциями чтения ничего не изменилось.
+
Следует отметить, что вполне нормально если выполнение _getter_ имеет некие _невидимые_ последствия, например, сохранение в кеше результатов некоторого вычисления для ускорения выполнения кода при следующем вызове. По факту, это одна из очень полезных возможностей функции "getter".

* Функция _setter_ должна всегда устанавливать значение таким образом, чтобы _getter_ вернул его же обратно. Не стоит автоматически отбрасывать неверные значения "setter", если это необходимо, стоит вызвать exception. Также не следует конвертировать или масштабировать запрашиваемое значение. Главная идея заключается в том, чтобы после установки `MyClass.MyProperty := 123;` программист ожидал, что `MyClass.MyProperty = 123`.

* _read-only свойства_ часто используют для создания неких полей доступных только для чтения снаружи. Снова таки, хорошеая практика - делать их поведение похожим на константу, по крайней мере для данного экземпляра объекта в его текущем состоянии. Значение свойства не должно меняться неожиданно. _Если необходимо возвращать что-то случайное, лучше сделать функцию, а не свойство._

* Поле, к которому обращаются свойства почти всегда находится в разделе _private_, поскольку главная идея свойств - служить обёрткой и методом доступа к нему.

* Технически, возможно создать свойства, которые только устанавливают значение, но не читают его. Впрочем, хороших примеров такой реализации мне ещё не встречалось :)

ПРИМЕЧАНИЕ: Свойства так же могут быть определены вне класса, на уровне модуля. Они служат аналогичной цели: они внешне выглядят как глобальные переменные, но доступ к ним вызывает соответствующие функции _getter_ и _setter_.

### Исключения

В паскале можно вызывать и использовать исключения. Их можно "ловить" с помощью конструкции `try ... except ... end`, также можно применять секцию "выполнить в конце" `try ... finally ... end`.

[source,pascal]
----
include::code-samples/exception_finally.lpr[]
----

Обратите внимание, что раздел `finally` будет выполнен даже в случае, если выполнение будет прекращено командой `Exit` (из функции, процедуры или метода), операторами `Break` или `Continue` (внутри тела цикла).

### Уровни видимости (Visibility specifiers)

Как и в большинстве объектно-ориентированных языках, в паскале имеются визуальные спецификаторы для ограничения "видимости" полей / методов / свойств.

Основные уровни видимости являются следующими:

`public`:: каждый имеет доступ, включая код в других модулях.
`private`:: доступен только только в этом классе.
`protected`:: доступен только в этом классе и его наследниках.

Краткое описание `private` и `protected`, данное выше, не полностью верно. Код в _текущем модуле_ может преодолевать эти границы, и получить доступ к `private` и `protected`. Иногда это полезная особенность, позволяющая реализовывать плотно связанные классы. В остальных же случаях следует использовать `strict private` или `strict protected` для организации полной недоступности данных методов, полей или свойств. Детальнее этот вопрос рассматривается в разделе <<private and strict private>>.

По умолчанию если видимость не указана, то видимость соответствует `public`. исключение составляют классы, которые объявляются при включённой директиве `{$M+}`, либо наследники классов, которые были скомпиллированы при `{$M+}`, что включает в себя всех потомков `TPersistent`, а также потомков `TComponent` (поскольку `TComponent` является потомком `TPersistent`). Для таких классов по умолчанию видимость принимается `published`, которая подобна `public`, однако позволяет работать с ними с помощью потоковой (stream) системы.

Однако, не каждой области или свойству типа позволено быть в секции published (не каждый тип может быть конвертирован в поток (stream), и лишь классы могут быть в потоке из простых полей). Если нет необходимости создавать потоки, но нужно просто что-то доступное для всех пользователей, то следует использовать `public`.

### Предок по умолчанию

Если не объявить класс-предок по умолчанию, каждый `class` наследует `TObject`.

## Освобождение памяти классов

### Всегда необходимо освобождать экземпляры класса
Чтобы избежать утечек памяти, все экзэмпляры класса должны быть освобождены вручную. Хорошей практикой является использование опции компиллятора FPC -gl -gh, чтобы обнаруживать утечки памяти (детальнее см. http://castle-engine.sourceforge.net/tutorial_optimization.php#section_memory ).

Следует обратить внимание, что это не касается поднятых исключений (raised exceptions). Не смотря на то, что при поднятии исключения действительно создаётся класс (и это вполне обычный класс, для этих целей также можно создавать свои классы), этот экземпляр класса освобождается автоматически.

### Каким образом освобождать память

Самым лучшим методом освобождения класса является операция `FreeAndNil(A)` вызванная для данного экземпляра класса. Она проверяет, не имеет ли `A` значение `nil`, и если нет -- вызывает его деструктор (destructor), и устанавливает значение `A` в `nil`. Таким образом повторный вызов такой процедуры не приведёт к ошибке.

Приблизительно это соответствует следующему:

[source,pascal]
----
if A <> nil then
begin
  A.Destroy;
  A := nil;
end;
----

Впрочем, это слишком упрощено, поскольку `FreeAndNil` совершает ещё одно полезное действие, сразу устанавливая `A` значение `nil` *до того* как будет вызван destructor данного класса. Это позволяет избежать целой группы багов благодаря тому, что "внешний" код не сможет получить доступ к не до конца уничтоженному экземпляру класса.

Иногда можно заметить, что применяется метод `A.Free` который соответствует следующему коду:

[source,pascal]
----
if A <> nil then
  A.Destroy;
----

Т.е. освобождает класс `A`, если он не равен `nil`.

Стоит отметить, что в нормальных условиях никогда не стоит вызывать метод класса, который может оказаться `nil`. По этому `A.Free` может выглядеть подозрительно на первый взгляд, поскольку `A` может иметь значение `nil`. Однако, метод `Free` является исключением из этого правила. Это выглядит немного "грязновато" -- а именно, выполняется проверка `Self <> nil`. Такой фокус работает только для не-виртуальных методов (т.е. в случае, если не вызываются виртуальные методы и не требуется доступ к полям класса).

По этому лучше всегда использовать `FreeAndNil(A)`, без исключений, и никогда не использовать метод `Free` или деструктор `Destroy`. Такой концепции придерживается _Castle Game Engine_. Это позволяет быть уверенным, что все ссылки _либо равны `nil`, либо указывают на существующий рабочий экземпляр класса_.

### Ручное и автоматическое освобождение памяти

Во многих ситуациях, необходимость освобождать instance не является чем-то сложным. Просто пишется destructor, как пара соответствующему constructor-у, и освобождает все объекты, память для которых была выделена в constructor-е (а, точнее, в продолжение всего времени существования класса). Следует следить за тем, чтобы освобождать каждый объект лишь *один раз*. Хорошей практикой будет устанавливать значение освобождённой ссылки в  `nil`, а наиболее удобно сделать это, вызвав команду `FreeAndNil(A)`.

Например:

[source,pascal]
----
uses SysUtils;

type
  TGun = class
  end;

  TPlayer = class
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  Gun1 := TGun.Create;
  Gun2 := TGun.Create;
end;

destructor TPlayer.Destroy;
begin
  FreeAndNil(Gun1);
  FreeAndNil(Gun2);
  inherited;
end;
----

Чтобы избежать необходимости каждый раз явно освобождать instance, можно использовать полезную особенность `TComponent`, которая называется _"ownership"_ (владение дочерним объектом). Любой объект, который _owned_ (т.е. которым данный класс владеет) будет автоматически освобождён _owner_-ом (классом, который им владеет). Механизм очень гибкий и никогда не освобождает объекты, которые уже освобождены (таким образом всё будет работать правильно и для несозданных объектов или освобождённых ранее). Таким образом предыдущий пример можно переписать так:

[source,pascal]
----
uses SysUtils, Classes;

type
  TGun = class(TComponent)
  end;

  TPlayer = class(TComponent)
    Gun1, Gun2: TGun;
    constructor Create(AOwner: TComponent); override;
  end;

constructor TPlayer.Create(AOwner: TComponent);
begin
  inherited;
  Gun1 := TGun.Create(Self);
  Gun2 := TGun.Create(Self);
end;
----

Следует обратить внимание, что также необходимо override virtual-ный constructor от `TComponent`. Это в свою очередь означает, что нельзя изменять параметры  constructor-а. Впрочем, это возможно -- объявив новый constructor с ключевым словом `reintroduce`. Однако здесь стоит быть осторожным, так как некоторый функционал, например, streaming, настроена на использование virtual constructor, по этому следует удостовериться, что в любом случае всё будет работать верно.

Ещё один механизм автоматического освобождения памяти -- функционал `OwnsObjects` (который по умолчанию `true`) классов-списков, таких, как `TFPGObjectList` или `TObjectList`. Т.е. можно написать:

[source,pascal]
----
uses SysUtils, Classes, FGL;

type
  TGun = class
  end;

  TGunList = specialize TFPGObjectList<TGun>;

  TPlayer = class
    Guns: TGunList;
    Gun1, Gun2: TGun;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TPlayer.Create;
begin
  inherited;
  // Вообще говоря, параметр OwnsObjects и так true по умолчанию
  Guns := TGunList.Create(true);
  Gun1 := TGun.Create(Self);
  Guns.Add(Gun1);
  Gun2 := TGun.Create(Self);
  Guns.Add(Gun2);
end;

destructor TPlayer.Destroy;
begin
  { Здесь достаточно освободить сам список.
    Он сам автоматически освободит всё содержимое. }
  FreeAndNil(Guns);

  { Таким образом нет нужды освобождать Gun1, Gun2 отдельно.
    Правда, хорошей практикой будет теперь установить их ссылку в "nil".
    поскольку мы знаем, что они освобождены. В этом простом классе с простым
    destructor-ом, очевидно, что к ним не произойдёт доступа, однако
    в случае сложных destructor-ов это может оказаться полезно.

    Альтернативно, можно избежать объявления Gun1 и Gun2 отдельно
    и использовать напрямую Guns[0] и Guns[1] в коде.
    Можно также создать метод Gun1, который ссылается на Guns[0]. }
  Gun1 := nil;
  Gun2 := nil;
  inherited;
end;
----

Заметим, что механизм "ownership" классов-списков простой и в случае высвобождения содержащейся в списке instance сторонним кодом возникнет ошибка. Чтобы исключить что-либо из списка без освобождения используется метод `Extract`, однако это также означает, что в дальнейшем элемент необходимо будет освобождать вручную.

В *Castle Game Engine*: Все descendants класса `TX3DNode` автоматически управляют памятью при добавлении как children другой `TX3DNode`. Корневая X3D node, `TX3DRootNode`, в свою очередь обычно владеется классом `TCastleSceneCore`. Другие объекты также имеют простой механизм владения -- обычно это обозначено parameter-ом или property под названием подобным `OwnsXxx`.

### Free notification

Если создать дополнительную ссылку на instance получается, что две ссылки указывают на одну и ту же область памяти. Если освободить одну из них, вторая окажется _"болтающимся" указателем_. Нельзя пытаться получить доступ к области памяти, которая была освобождена. Это может привести к runtime ошибке (чаще всего SIGSEGV), либо может быть получено неопределённое значение (в случае, если эта область памяти уже повторно выделена для других элементов внутри текущей программы).

В таком случае не достаточно просто вызывать `FreeAndNil` поскольку эта функция установит `nil` лишь для переданной её ссылки -- не существует автоматического метода. Рассмотрим следующий пример:

[source,pascal]
----
var
  Obj1, Obj2: TObject;
begin
  Obj1 := TObject.Create;
  Obj2 := Obj1;
  FreeAndNil(Obj1);

  // что произойдёт, если попытаться получить доступ к объекту Obj1 или Obj2?
end;
----

1. В конце данного блока ссылка `Obj1` является `nil`. Если необходимо получить доступ к ней в коде программы, для надёжности следует использовать проверку `if Obj1 <> nil then ...` чтобы случайно не вызвать метод уже освобождённой instance, например:
+

[source,pascal]
----
if Obj1 <> nil then
  Writeln(Obj1.ClassName);
----
+
Попытка доступа к ссылке `nil` на instance приведёт к предсказуемой и понятной ошибке. Таким образом, даже если код не будет проверять `Obj1 <> nil`, и попытается вслепую получить доступ к `Obj1`, возникнет достаточно ясное сообщение об ошибке.
+
То же самое происходит и при попытке вызова virtual method, или не-virtual method который пытается получить доступ к полю освобождённой instance.

2. Ситуация с `Obj2` -- куда сложнее. Её значение не `nil`, однако оно ошибочно. Попытка доступа к не-nil неверной ссылки на instance
//(or call a method that accessed a field of such instance)
приводит к непредсказуемому результату -- это может быть и access violation exception, а может и какое-то случайное значение.

К решению такой проблемы есть несколько путей:

* Первое решение - внимательно читать документацию к объекту. Не предполагать ничего о длительности жизни ссылки, если она создана чужим кодом. Если в классе `TCar` есть поле, указывающее на instance типа `TWheel`, то есть _правило_ что ссылка на _wheel_ верна, пока существует класс _car_, и сам _car_ освободит все его _wheel_ используя свой destructor. Но это правило, в более сложных случаях в документации следует сделать упоминание того, как и что происходит со ссылками.

* В примере выше, сразу после освобождения `Obj1` instance, можно просто вручную установить `Obj2` значение `nil`. В данном конкретном примере это просто и тривиально.

* Однако, наиболее перспективным решением использовать специальный механизм класса `TComponent` под названием "free notification" (извещение об освобождении). Этим образом один компонент может получить notification в случае освобождения одной из компонент, и далее установить ссылку на неё в `nil`.
+
Таким образом можно получить _слабую ссылку_. Использовать эту механику можно в различных задачах, например, позволить коду извне изменять ссылки, в том числе, возможность освобождать память в любой момент.
+
Для этого оба класса должны наследовать `TComponent`. Обычно это сводится к использованию `FreeNotification` , `RemoveFreeNotification`, и override `Notification`.
+
Следующий пример демонстрирует как использовать этот подход вместе с constructor / destructor и setter property. Иногда можно всё сделать намного проще, но здесь демонстрируется полномасштабная версия, которая будет верной в любом случае.
+
[source,pascal]
----
type
  TControl = class(TComponent)
  end;

  TContainer = class(TComponent)
  private
    FSomeSpecialControl: TControl;
    procedure SetSomeSpecialControl(const Value: TControl);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    destructor Destroy; override;
    property SomeSpecialControl: TControl
      read FSomeSpecialControl write SetSomeSpecialControl;
  end;

implementation

procedure TContainer.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSomeSpecialControl) then
    { установить значение nil для SetSomeSpecialControl чтобы всё аккуратно подчистить }
    SomeSpecialControl := nil;
end;

procedure TContainer.SetSomeSpecialControl(const Value: TControl);
begin
  if FSomeSpecialControl <> Value then
  begin
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.RemoveFreeNotification(Self);
    FSomeSpecialControl := Value;
    if FSomeSpecialControl <> nil then
      FSomeSpecialControl.FreeNotification(Self);
  end;
end;

destructor TContainer.Destroy;
begin
  { Установить значение nil для SetSomeSpecialControl, чтобы запустить notification про освобождение памяти }
  SomeSpecialControl := nil;
  inherited;
end;
----

## Run-time library

### Ввод/вывод с помощью потоков

Для ввода / выода в современных программах на паскалях используется класс `TStream`. У него также есть множество полезных производных классов, таких как `TFileStream`, `TMemoryStream`, `TStringStream`.

[source,pascal]
----
include::code-samples/file_stream.lpr[]
----

В *Castle Game Engine* следует использовать метод `Download` для создания потока, который оперирует ресурсами (это могут быть файлы, данные, скачанные с URL или Android assets). Более того, для открытия ресурсов в игровых данных (обычно это под-папка `data`) используйте функцию `ApplicationData`.

[source,pascal]
----
EnableNetwork := true;
S := Download('http://castle-engine.sourceforge.net');
----

[source,pascal]
----
S := Download('file:///home/michalis/my_binary_file.data');
----

[source,pascal]
----
S := Download(ApplicationData('gui/my_image.png'));
----

Чтобы прочитать обычный текстовый файл лучше использовать класс `TTextReader` из `CastleClassUtils`. Он предоставляет построчный API, как надстройку над `TStream`. URL можно задать через конструктор класса `TTextReader`, либо можно передать ему готовый `TStream` вручную.

[source,pascal]
----
Text := TTextReader.Create(ApplicationData('my_data.txt'));
while not Text.Eof do
  WritelnLog('NextLine', Text.ReadLine);
----

### Списки

Для создания различных списков переменной длинны, лично я советую использовать generic классы из unit-а `FGL`. Можно использовать `TFPGList` для простых типов данных (включая record-ы или устаревшие object-ы), и `TFPGObjectList` для списка экземпляров классов. В *Castle Game Engine:* можно также использовать  `CastleGenericLists` с `TGenericStructList` для создания списков record-ов или устаревших object-ов. Это позволяет обойти проблему невозможности override их операторов в старых версиях FPC.

Применение таких списков является хорошей идеей по нескольки причинам: они типо-безопасны и их API имеет много полезных функций, таких как поиск, сортировка, итерация и т.п. Вообще говоря, не стоит использовать _динамические массивы_ (`array of X`, `SetLength(X, ...)`) поскольку их API очень неудобный - можно применить лишь `SetLength`. Также не стоит использовать `TList` или `TObjectList` as it will require casting your references from `TObject` to your type.

### Клонирование объектов: TPersistent.Assign

Для того, чтобы получить возможность копирования класса, стандартный подход является наследование этим классом `TPersistent` и затем override его метод `Assign`. Здесь нет ничего сложного, просто нужно в методе `Assign` прописать копирование полей, которые Вам необходимы.

Однако, здесь понадобится достаточно аккуратный подход в имплементации метода `Assign`, поскольку копирование может происходить не только из данного класса, а и из производных от него.

[source,pascal]
----
include::code-samples/persistent.lpr[]
----

Иногда более удобно написать альтернативный override метода `AssignTo` в копируемом классе, а не делать overriding метода `Assign` в классе, в который выполняется копирование.

Следует быть осторожным с `inherited` при написании `Assign`. _Inherited_ `TPersistent.Assign` должен вызываться иселючительно в случаях, если Вы не можете самостоятельно выполнить копирование в своём коде (это позволит использовать метод `AssignTo`, т.к. в противоположном случае возникнет  exception, когда копирование не может быть выполнено). С другой стороны, если данный класс является производным от класса, в котором уже есть метод `Assign`, то в данном случае _следует обязательно вызывать inherited_ ``TMyClass.Assign``. См. пример выше.

Примечание: Обратите внимание, что наследуя класс `TPersistent` по умолчанию видимость полей становится `published`, чтобы дать возможность переводить в поток (streaming) производные от `TPersistent` классы. Однако, не все типы полей (field) и свойств (property) разрешены в секции `published`. Если возникают связанные с этим ошибки и нет необходимости передавать эти данные в поток, просто вручную измените уровень видимости на `public`. Детальнее см. раздел <<Уровни видимости (Visibility specifiers)>>.

## Различные полезные возможности языка

### Местные (вложенные) процедуры - Local (nested) routines

Внутри большой _процедуры_ (это может быть function, procedure, method, и т.п.) можно определить вложенную под-процедуру.

//It has all the flexibility of a normal routine, it's just not
//This is quite powerful feature that allows you to _easily_ split a long routine into many smaller ones.

Таким образом такая локальная под-процедура имеет полный доступ (чтение и запись) всех параметров процедуры, в которой она находится, _если они были объявлены раньше, чем эта процедура_. Это очень удобно, часто позволяя разделять длинные процедуры в несколько небольших частей без особых дополнительных усилий (поскольку нет необходимости передавать множество информации в виде параметров). Однако, не следует злоупотреблять этой возможностью. В случае, если местная (вложенная) использует и, тем более, изменяет много перемен процедуры, в которой она находится, тако код становится сложным для понимания.

Данные два примера абсолютно эквивалентны:

[source,pascal]
----
procedure SumOfSquares(const N: Integer): Integer;

  function Square(const Value: Integer): Integer;
  begin
    Result := Value * Value;
  end;

var
  I: Integer;
begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square(I);
end;
----

И второй вариант, в котором `Square` получает прямой доступ к переменной `I`:

[source,pascal]
----
procedure SumOfSquares(const N: Integer): Integer;
var
  I: Integer;

  function Square: Integer;
  begin
    Result := I * I;
  end;

begin
  Result := 0;
  for I := 0 to N do
    Result := Result + Square;
end;
----

Местные процедуры могут быть много раз вложенными -- что означает, что внутри локальной процедуры можно определить местную локальную под-процедуру и т.д. Однако, не стоит этим злоупотреблять, поскольку в результате код может стать совершенно нечитабельным.

[[Callbacks]]

### Callbacks -- они же события, они же указатели на функции, они же процедурные переменные (procedural variables)

Они позволяют вызвать функцию не прямым указанием её названия, а через переменную. Эта переменная может быть назначена во время исполнения кода для указания на любую функцию _с указанными типами параметров и возвращаемых величин_.

Callback-и могут быть:

* Обычными, что означает, что они могут указывать на любую нормальную функцию (не метод и не локальная функция)
+
[source,pascal]
----
include::code-samples/callbacks.lpr[]
----

* Указывающими на метод: для этого в конце добавляется `of object`.
+
[source,pascal]
----
include::code-samples/callbacks_of_object.lpr[]
----
+
Следует заметить, что _невозможно_ передать глобальные процедуры или функции как методы. Они несовместимы. Если Вам необходимо использовать callback `of object`, но не хотите создавать экземпляр-пустышку для класса, Вы можете передавать <<Class methods>> в качестве метода.
+
[source,pascal]
----
type
  TMyMethod = function (const A, B: Integer): Integer of object;

  TMyClass = class
    class function Add(const A, B: Integer): Integer
    class function Multiply(const A, B: Integer): Integer
  end;

var
  M: TMyMethod;
begin
  M := @TMyClass(nil).Add;
  M := @TMyClass(nil).Multiply;
end;
----
+
К сожалению, придётся писать громоздкую конструкцию `@TMyClass(nil).Add`, а не просто `@TMyClass.Add`.

* Может указывать на локальную процедуру: для этого её нужно объявить с `is nested` в конце, а также установить директиву `{$modeswitch nestedprocvars}` для данного участка кода. Детальнее см. <<Местные (вложенные) процедуры - Local (nested) routines>>.

### Дженерики (Generics)

Это - очень мощная функция современных языков. Определение чего-либо (обычно - класса) может быть параметризировано с другим типом. Наиболее естественным примером является необходимость создать контейнер (список, словарь, дерево, граф...): Можно определить _a list of type T_, а потом _specialize_ (конкретизировать) его чтобы сразу получить _a list of integers_, _a list of strings_, _a list of TMyRecord_, и т.д.

Generic-и в Паскале реализованы весьма подобно generic-ам в C++. Это означает, что они "конкретизируются" когда происходит specialize, что _немного_ похоже на поведение макросов (однако, когда тип "конкретизирован", используются только эти определения, и таким образом невозможно "добавить" какое-либо неожиданное поведение в дженерик без его "конкретизирования"). Преимуществом их является высокая скорость выполнения (оптимизированная для каждого конкретного типа) и поддержка типов любого размера. Можно использовать примитивные типы (integer, float) а также record, class и т.п. при specialize данного generic-а.
// Unlike in Java, you are *not* limited to only generics of things that are a reference.

[source,pascal]
----
include::code-samples/generics.lpr[]
----

Возможности generic-ов не ограничиваются классами, можно создать generic функции и процедуры:

[source,pascal]
----
include::code-samples/generic_functions.lpr[]
----

### Оверлоадинг (Overloading)

Методы (и глобальные функции и процедуры) с одинаковым именем могут существовать при условии, что они принимают разные параметры. На основании передаваемых процедуре параметров компиллятор определяет, какую именно из этих функций использовать.

По умолчанию overloading использует стиль FPC, что означает, что абсолютно все имена в пространстве имён (namespace) (в class-е или unit-е) равны, и скрывает все остальные методы в пространстве имён с более низким приоритетом. Например, если создать класс с методом `Foo(Integer)` и `Foo(string)`, и при этом класс наследует класс в котором уже есть `Foo(Float)`, то метод `Foo(Float)` невозможно будет вызвать напрямую, только с помощью typecast данного class на родительский класс. Чтобы избежать такого поведения, при объявлении процедур и функций следует использовать ключевое слово `overload`, где это необходимо.

### Предобработка кода

Можно использовать простые директивы предобработки кода для того, чтобы:

* компилляция на основании различных условий (например, если код зависит от платформы, или других заданных вручную параметров),
* чтобы включить один файл внутри другого,
* для вызова беспараметрических макросов.

Обратите внимание, макросы с параметрами запрещены. В общем, следует избегать предобработки кода кроме случаев, когда она действительно нужна. Предобработка происходит перед парсингом, что значит, что она вполне может "ломать" обычный синтаксис языка Паскаль. Это мощно, но немного "грязно".

[source,pascal]
----
{$mode objfpc}{$H+}{$J-}
unit PreprocessorStuff;
interface

{$ifdef FPC}
{ всё что идёт внутри определено только для FPC, а не других компилляторов (например, Delphi). }
procedure Foo;
{$endif}

{ Определить константу NewLine. Здесь представлен пример,
  как "нормальный" синтаксис Паскаля "поломан" директивами предобработки. 
  Если компилировать на Unix-системах (включая  Linux, Android, Mac OS X),
  компиллятор увидит следующее:

    const NewLine = #10;

  Если компилировать на Windows, компиллятор увидит так:

    const NewLine = #13#10;

  Однако, на других операционных системах, код не скомпилируется,
  поскольку компиллятор увидит следующее:

    const NewLine = ;

  Вообще, это *хорошо* что возникает ошибка в данном случае -- если возникнет
  необходимость портировать программу на другую операционную систему,
  которая не является ни Unix, ни Windows, то компиллятор "напомнит", что
  необходимо выбрать правильное значение NewLine для такой системы. }

const
  NewLine =
    {$ifdef UNIX} #10 {$endif}
    {$ifdef MSWINDOWS} #13#10 {$endif} ;

{$define MY_SYMBOL}

{$ifdef MY_SYMBOL}
procedure Bar;
{$endif}

{$define CallingConventionMacro := unknown}
{$ifdef UNIX}
  {$define CallingConventionMacro := cdecl}
{$endif}
{$ifdef MSWINDOWS}
  {$define CallingConventionMacro := stdcall}
{$endif}
procedure RealProcedureName; CallingConventionMacro; external 'some_external_library';

implementation

{$include some_file.inc}
// $I это удобное сокращение от $include, они идентичны
{$I some_other_file.inc}

end.
----

Включаемые файлы обычно имеют расширение `.inc`, и используются для следующих двух целей:

* Включаемый файл может содержать лишь другие директивы компиллятора, которые "конфигурируют" исходный код программы. Например, можно создать файл `myconfig.inc` со следующим содержанием:
+
[source,pascal]
----
{$mode objfpc}
{$H+}
{$J-}
{$modeswitch advancedrecords}
{$ifndef VER3}
  {$error This code can only be compiled using FPC version at least 3.x.}
{$endif}
----
+
Теперь можно включить этот файл `{$I myconfig.inc}` в каждом unit-е исходного кода.

* Второй важный пример использования - разделение unit-а на несколько файлов, и при этом всё же держать его одним модулем (с учётом всех особенностей Паскаля). Не стоит злоупотреблять таким подходом. В первую очередь стоит думать о том, как разделить программу на несколько unit-ов, а не разделять её на множество include файлов. Однако, в общем, это довольно полезная и удобная техника.
  . Такой подход позволяет избежать огромного количества unit-ов, и при этом исходные файлы будут не слишком длинными. Например, куда удобнее иметь один файл с _"часто используемыми GUI элементами"_, чем создавать _отдельные unit-ы для каждого GUI элемента"_, поскольку второй вариант сделает обычную "uses" неоправданно длинной (поскольку в GUI будут использоваться множество GUI элементов). Однако, размещение всех этих классов в одном файле `myunit.pas` приведёт к его большому размеру, что в свою очередь затруднит навигацию по файлу. Таким образом, разбить этот файл на несколько include файлов будет разумным.
//For example, *Castle Game Engine* has a unit `CastleControls` with a couple of user-interface controls, like `TCastleButton`, `TCastleLabel`, `TCastleImageControl` and more. We could split it into many units, even to _one unit per class_, as the classes are not really tightly connected. But that would often force you to have a long `uses` clause, since a lot of user-interface code will want to use a couple of control classes. So we made a practical decision to just put all _often used controls_ in a single unit.
  . Такой подход также позволяет легко создавать кросс-платформенный unit с уникальными частями для каждой платформы. Например, это может выглядеть так:
+
[source,pascal]
----
{$ifdef UNIX} {$I my_unix_implementation.inc} {$endif}
{$ifdef MSWINDOWS} {$I my_windows_implementation.inc} {$endif}
----
+
Иногда это более удобно, чем написать длинный код со множеством `{$ifdef UNIX}`, `{$ifdef MSWINDOWS}` в перемешку с нормальным кодом (определение переменных, описание процедур). Повышается и читабельность кода. Эту технику можно использовать более агрессивно, используя опцию коммандной строки `-Fi` при вызове FPC, чтобы включить целые папки только для конкретных платформ. Таким образом можно иметь множество версий include файлов типа `{$I my platform_specific_implementation.inc}`. При этом компилятор автоматически найдёт правильную версию.

### Record

_Record_ является своеобразным контейнером для других переменных. Она является очень, очень упрощённым _классом_: нет наследования, нет виртуальных методов. Она также подобна _structure_ в C-подобных языках.

Если использовать директиву `{$modeswitch advancedrecords}`, то в record *возможно* добавить методы и уровни видимости. В общем, тут можно использовать любые возможности языка, доступные классам, которые _не нарушают простую и предсказуемую раскладку памяти для record_.

[source,pascal]
----
include::code-samples/records.lpr[]
----

В современном Паскале, в первую очередь лучше использовать `class`, а не `record` -- поскольку классы имеют множество полезных возможностей, как конструкторы и наследование.
Однако, record-ы всё ещё могут быть полезными если необходима скорость или предсказуемая раскладка памяти:

* Record-ам не требуется constructor или destructor. Они определяются как переменные. Их содержимое не определено в начале (так называемый "мусор в памяти"), кроме случаев, автоматически управляемых типов, таких как string, которые всегда инициализируются пустыми. Таким образом следует быть более аккуратным при их использовании, однако преимуществом такого подхода будет увеличение скорости исполнения программы.
* Массивы, состоящие из record-ов однородно располагаются в памяти и таким образом их удобно кешировать.
* Память для record-ов чётко определена (размер и расстояние между каждым полем) в некоторых ситуациях: когда запрашивается _C layout_ или если используется `packed record`. Это может быть полезным в следующих случаях:
** для связи между библиотеками, написанными в других языках программирования и предоставляющих API, который основывается на данных типа record,
** для чтения и записи бинарных файлов,
** для выполнения "грязных" низкоуровневых оптимизаций (как небезопасное  typecasting одного типа в другой, когда понятно их представление в памяти).
* В record-ах можно также использовать часть `case`, которая работает как _union_ в C-подобных языках. Это позволяет интерпретировать один и тот же регион памяти, как различные типы данных, в зависимости от необходимости. Таким образом возможно достичь более высокой эффективности памяти в некоторых случаях. В том числе можно выполнять некоторые "грязные" низкоуровневые оптимизации.

### Устаревшие object

Давным-давно, в Turbo Pascal был введён новый тип синтаксиса с функциональностью, похожей на классы. Он был определён ключевым словом `object`. По сути, это нечто среднее между `record` и современным `class`.

* Такие object-ы можно создавать / освобождать, и в этом процессе можно вызвать их constructor / destructor.
* Но их можно просто объявить и использовать как обычную record. Простые типы `record` или `object` не являются указателями (pointer-ами) на что-либо, они являются данными. Это делает их весьма удобными в случаях небольших объёмов данных, когда многократное распределение или освобождение памяти не всегда оправдано.
//It also makes them fast -- a list of such structures is nicely linear in memory, iterating over it doesn't involve jumping over pointers. Also, their memory layout is defined in _some_ situations (packed records, or records with C layout), which makes them suitable to pass to external APIs, like OpenGL.
* Устаревшие object-ы имеют наследование и виртуальные методы, впрочем, в несколько отличном виде от современных классов. Будьте внимательны -- если попытаться использовать object, имеющий виртуальные методы, без вызова его constructor-а, могут возникнуть ошибки.

В большинстве случаев крайне не советуется использовать устаревшие objects-ы. Современные _class-ы_ имеют гораздо более широкий функционал. А в случае если необходимо повысить скорость выполнения, можно использовать record-ы (включая _advanced records_). Такие подходы обычно лучше, чем устаревшие object-ы.

### Указатели (Pointer)

В Паскале возможно создать указатель (_pointer_) на любой тип данных. Указатель на тип `TMyRecord` определяется с помощью синтаксиса `^TMyRecord`, и чаще всего такие указатели называют `PMyRecord`. Вот классический пример связанного списка целых чисел, организованного с помощью record:

[source,pascal]
----
type
  PMyRecord = ^TMyRecord;
  TMyRecord = record
    Value: Integer;
    Next: PMyRecord;
  end;
----

Обратите внимание, тут было использовано рекурсивное определение (тип `PMyRecord` определяется с помощью `TMyRecord`, а `TMyRecord` использует в своём определении `PMyRecord`). Можно определить указатель на тип, _который ещё не был объявлен_, в том случае, если он будет определён в том же самом блоке `type`.

Вы можете распределять и освобождать память для указателей с помощью методов `New` / `Dispose`, или (более низкоуровневых, но не типобезопасных) методов `GetMem` / `FreeMem`. Для доступа к данным, на которые pointer указывает после него следует добавить оператор `^` (в виде `PMyRecord^.Value`). Обратная операция (получить pointer на существующую переменную) выполняется с помощью оператора-префикса `@` (например, `@myRecordVariable`).

Существует также самый общий тип `Pointer`, который не указывает на конкретный тип данных и подобен `void*` в C-подобных языках. Он совершенно не типобезопасен, и его можно typecast в любой другой тип pointer-а.

Следует помнить, что _экземпляр класса_ также является pointer-ом, хоть для работы с ним и не нужно использовать дополнительных операторов `^` и `@`.
//That's why it's called a _reference_.
Связанные списки в виде классов также возможны и в данном случае всё будет выглядеть ещё проще:

[source,pascal]
----
type
  TMyClass = class
    Value: Integer;
    Next: TMyClass;
  end;
----

### Перегрузка операторов (overloading)

В Паскале существует возможность перегрузить (overload) значение многих операторов языка, например определить сложение и умножение пользовательских типов данных. Например:

[source,pascal]
----
include::code-samples/operator_overloading.lpr[]
----

Можно также перегрузить операторы над классами. Учитывая то, что обычно в такой функции-операторе создаётся новый экземпляр класса, вызывающий объект должен позаботиться об надлежащем освобождении памяти.

[source,pascal]
----
include::code-samples/operator_overloading_classes.lpr[]
----

Можно перегрузить и операции над record-ами. Обычно это проще, чем в случае классов, поскольку нет необходимости выполнять операции по распределению или освобождению памяти.

[source,pascal]
----
include::code-samples/operator_overloading_records.lpr[]
----

При работе с record-ами лучше использовать режим `{$modeswitch advancedrecords}` и перегружать операторы как `class operator` внутри record-а. Такой подход позволяет использовать generic классы которые зависят от существования какого-либо оператора (например `TFPGList`, который зависит от доступности оператора равенства). В противоположном случае "глобальное" определение оператора (не внутри данной record) будет не найдено (поскольку он не доступен коду, который используется в `TFPGList`), и не удастся specialize список в виде `specialize TFPGList<TMyRecord>`.

[source,pascal]
----
include::code-samples/operator_overloading_records_lists.lpr[]
----

## Дополнительные возможности классов

### Различие private и strict private

Спецификатор видимости `private` означает что поле или метод не доступны извне данного класса. Однако из данного правила есть одно исключение: любой код _в данном unit-е_ может преодолеть это ограничение и иметь полный доступ к private полям и методам. Программист на C++ сказал бы, что в Паскале _все классы в одном unit-е являются "друзьями"_. Часто это весьма удобно.

Однако, при создании unit-ов большого размера со множеством не очень близко интегрированных классов, более безопасным является применение видимости `strict private`. Как можно легко догадаться, это означает что поле или метод не доступны извне данного класса. Точка. Никаких исключений.

Таким же образом различаются спецификаторы видимости `protected` (видимый наследникам данного класса или "друзьям" в том же unit-е) и `strict protected` (видимы только и исключительно наследникам данного класса, точка).

### Class method

Существуют методы, которые можно вызвать из класса вообще (`TMyClass`), не обязательно из его конкретного экземпляра.

[source,pascal]
----
type
  TEnemy = class
    procedure Kill;
    class procedure KillAll;
  end;

var
  E: TEnemy;
begin
  E := TEnemy.Create;
  try
    E.Kill;
  finally FreeAndNil(E) end;
  TEnemy.KillAll;
end;
----

Обратите внимание, что они также могут быть виртуальными -- иногда это весьма удобно, особенно, если применяется совместно с <<Class references>>.

Следует отметить, что constructor всегда работает, как class method когда вызывается "обычным образом" (`MyInstance := TMyClass.Create(...);`). Впрочем, можно вызвать конструктор в данном конкретном экземпляре класса как метод и он тогда и сработает как обычный метод. Таким образом можно сделать удобную "цепочку" constructor-ов, когда один constructor (например, перегруженный для принятия дополнительных параметров) выполняет какую-то свою работу, а потом вызывает другой constructor (например, беспараметрический).

### Дополнительные возможности объявления классов и локальные классы

Внутри определения класса можно создавать константы (`const`) или типы (`type`). Таким образом можно даже создать класс внутри класса. Спецификаторы видимости будут работать как обычно, и такие локальные классы могут быть private (не видимые "внешнему миру"), что иногда удобно.
//The compiler watches that you don't break the visibility rules (for example you cannot declare a _public function_ that returns a type that is _private_).
// (I wish - it doesn't, unfortunately...)

Обратите внимание, чтобы определить поле после константы или типа будет необходимо использовать блок `var`:

[source,pascal]
----
type
  TMyClass = class
  private
    type
      TInternalClass = class
        Velocity: Single;
        procedure DoSomething;
      end;
    var
    FInternalClass: TInternalClass;
  public
    const
      DefaultVelocity = 100.0;
    constructor Create;
    destructor Destroy; override;
  end;

constructor TMyClass.Create;
begin
  inherited;
  FInternalClass := TInternalClass.Create;
  FInternalClass.Velocity := DefaultVelocity;
  FInternalClass.DoSomething;
end;

destructor TMyClass.Destroy;
begin
  FreeAndNil(FInternalClass);
  inherited;
end;

{ Обратите внимание на префикс "TMyClass.TInternalClass". }
procedure TMyClass.TInternalClass.DoSomething;
begin
end;
----

### Ссылки на класс

_Ссылки на класс_ позволяют выбрать класс в процессе исполнения программы, например, для вызова class method-а или constructor-а не определив, какой именно класс будет использоваться во время написания программы. Такой тип объявляется следующим образом: `class of TMyClass`.

[source,pascal]
----
type
  TMyClass = class(TComponent)
  end;

  TMyClass1 = class(TMyClass)
  end;

  TMyClass2 = class(TMyClass)
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  // Можно сделать так:

  C := TMyClass.Create(nil); FreeAndNil(C);
  C := TMyClass1.Create(nil); FreeAndNil(C);
  C := TMyClass2.Create(nil); FreeAndNil(C);

  // А с помощью ссылки на класс можно сделать следующее:

  ClassRef := TMyClass;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass1;
  C := ClassRef.Create(nil); FreeAndNil(C);

  ClassRef := TMyClass2;
  C := ClassRef.Create(nil); FreeAndNil(C);
end;
----

Ссылки на класс можно комбинировать с виртуальными class method-ами. Работает это подобно классам с виртуальными методами -- конкретный метод, который необходимо выполнить определяется уже в процессе выполнения программы.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    class procedure DoSomething; virtual; abstract;
  end;

  TMyClass1 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClass2 = class(TMyClass)
    class procedure DoSomething; override;
  end;

  TMyClassRef = class of TMyClass;

var
  C: TMyClass;
  ClassRef: TMyClassRef;
begin
  ClassRef := TMyClass1;
  ClassRef.DoSomething;

  ClassRef := TMyClass2;
  ClassRef.DoSomething;

  { А следующяя строка приведёт к ошибке выполнения,
    поскольку DoSomething является abstract в TMyClass. }
  ClassRef := TMyClass;
  ClassRef.DoSomething;
end;
----

Если есть экземпляр класса и необходимо создать ссылку на этот класс (не на какой-либо объявленный класс, а на конкретного наследника, который был использован при его создании), можно использовать свойство `ClassType`. Вообще говоря, объявленный тип `ClassType` является `TClass`, который в свою очередь является `class of TObject`. Часто его можно typecast во что либо более конкретное, когда есть информация, чем именно является данный экземпляр.

В общем, можно использовать `ClassType` для вызова виртуальных методов, включая виртуальные constructor-ы. Такой подход позволяет создать методы такие, как `Clone` которые создают экземпляр _как точную копию данного класса в этот момент исполнения программы_. Можно совместить такой подход с <<Cloning: TPersistent.Assign>> для того, чтобы метод возвращал новый, готовый к работе клон текущего экземпляра.

Следует обратить внимание, что подобный подход сработает только если constructor данного класса виртуальный. Например, такой подход можно использовать с наследниками стандартного класса `TComponent`, поскольку они все выполняют override виртуального constructor-а `TComponent.Create(AOwner: TComponent)`.

[source,pascal]
----
type
  TMyClass = class(TComponent)
    procedure Assign(Source: TPersistent); override;
    function Clone(AOwner: TComponent): TMyClass;
  end;

  TMyClassRef = class of TMyClass;

function TMyClass.Clone(AOwner: TComponent): TMyClass;
begin
  // Таким образом будет создан объект конкретного типа TMyClass:
  //Result := TMyClass.Create(AOwner);
  // А такой подход может создать объект как типа TMyClass так и его наследников:
  Result := TMyClassRef(self.ClassType).Create(AOwner);
  Result.Assign(Self);
end;
----

// This is an example why compiler cannot detect *all* uses of an abstract
// methods at compile time, in this case --- the error can only resurface
// at runtime.
//
// Poor example actually, since compiler could prevent "ClassRef := TMyClass"
// in this case?

### Class helpers (помощники для класса)

_Метод (method)_ является лишь процедурой внутри конкретного класса. Извне класса он вызывается с помощью специального синтаксиса `MyInstance.MyMethod(...)`. И через некоторое время приходит привычка, что _если нужно произвести действие над классом X, следует писать_ `X.Action(...)`.

Однако, иногда возникает необходимость выполнить что-либо, что концептуально является _действием на класс TMyClass_, однако при этом не изменяя исходный код _TMyClass_. Причин тому может быть несколько. Например, это может быть исходный код, написанный другим программистом, который не следует или невозможно изменять. Также иногда причиной тому могут быть зависимости -- добавление метода `Render` к классу `TMy3DObject` кажется вполне логичным, однако, возможно, имплементация класса `TMy3DObject` должна быть независимой от кода рендера? В таких случаях удобнее "расширить" существующий класс, добавив к нему функционал, при этом не изменяя его исходный код.

Наиболее простой путь сделать это - создать глобальную процедуру, которая будет принимать ссылку на `TMy3DObject` как параметр.

[source,pascal]
----
procedure Render(const O: TMy3DObject; const Color: TColor);
var
  I: Integer;
begin
  for I := 0 to O.ShapesCount - 1 do
    RenderMesh(O.Shape[I].Mesh, Color);
end;
----

И это действительно сработает. Однако, недостаток такого подхода - он выглядит не очень красиво. Ведь обычно мы вызываем действия над объектом с помощью `X.Action(...)`, а тут нам приходится использовать иной синтаксис: `Render(X, ...)`. Было бы куда удобнее записать `X.Render(...)`, даже для случаев, когда `Render` не описан в unit-е, в котором находится `TMy3DObject`.

Для этого и существуют class helpers, дающие возможность создать процедуры/функции, которые оперируют данным классом и вызываются так как и остальные методы класса, однако не являются "обычными" методами -- они добавляются извне определения класса `TMy3DObject`.

[source,pascal]
----
type
  TMy3DObjectHelper = class helper for TMy3DObject
    procedure Render(const Color: TColor);
  end;

procedure TMy3DObjectHelper.Render(const Color: TColor);
var
  I: Integer;
begin
  // note that we access ShapesCount, Shape without any qualifiers here
  for I := 0 to ShapesCount - 1 do
    RenderMesh(Shape[I].Mesh, Color);
end;
----

	ПРИМЕЧАНИЕ: Более общяя концепция является _"type helper"_, используя которую становится возможным добавлять методы даже к самым примитивным типам, например integer. Можно даже создать _"record helpers_" чтобы... ну, Вы поняли. Детальнее см. здесь: http://lists.freepascal.org/fpc-announce/2013-February/000587.html .
//And of course to records and old-style objects (both of them can also have regular methods, they are much like classes in this regard).

### Виртуальные constructor-ы, destructor-ы

Имя destructor-а всегда должно `Destroy`, и он всегда является virtual (поскольку он вызывается без указания конкретного класса при компилляции) и беспараметрический.

Имя constructor-а принято использовать `Create`.

Его можно изменить, однако здесь следует быть аккуратным -- например, создав `CreateMy`, всегда создайте и `Create`, иначе constructor `Create` будет всё равно доступен из родительского класса и может быть вызван в обход конкретного `CreateMy` конструктора.

В базовом классе `TObject` constructor не является виртуальным, и при создании наследников его можно изменить. Новый constructor просто спрячет constructor родительского класса (примечание: не используйте `overload` для этого, в данном случае это не сработает).

В наследниках класса `TComponent`, следует выполнять override constructor-а `constructor Create(AOwner: TComponent);`. Для решения задач потоковой передачи данных, а также для создания класса без указания конкретного типа при написании программы, виртуальные constructor-ы являются очень удобными (см. раздел <<Ссылки на класс>> выше).

### Ошибки при исполнении constructor-а

Что произойдёт если в процессе выполнения constructor-а возникнет ошибка? Строка

[source,pascal]
----
X := TMyClass.Create;
----

не будет выполнена до конца, и `X` не может быть присвоено какое-либо значение. Кто будет выполнять очистку после частично сконструированного класса?

В Object Pascal существует следующее решение. Если возникла ошибка при исполнении constructor-а, то сразу вызывается destructor. Именно по этой причине _этот destructor должен быть "дубовым"_, т.е. сработать в любом случае, даже на частично сконструированном классе. Обычно это не сложно, если освобождать всё безопасно, например, с помощью `FreeAndNil`.

Также можно полагаться на факт, что перед вызовом constructor-а _вся память гарантированно обнуляется_ перед его исполнением. Таким образом, при создании все ссылки внутри класса являются `nil`, а числа равны 0 и т.п.

Т.е. следующий код сработает без утечек памяти (memory leaks):

[source,pascal]
----
include::code-samples/exception_in_constructor_test.lpr[]
----

## Интерфейсы

### Хорошие (CORBA) интерфейсы

_Интерфейс_ объявляет API, так же как и класс, но он не определяет реализацию(implementation). Класс может выполнять множество интерфейсов, но он может иметь только один класс-предок.

Вы можете привести класс к любому интерфейсу, его поддерживающий,и тогда _вызывать методы через этот интерфейс_. Это позволяет обрабатывать классы единообразно, которые не происходят друг от друга, но которые имеют общие функциональные возможности. Полезно когда не хватает простого наследования классов.

_Интерфейсы CORBA_ в Object Pascal работают в значительной степени так, как и интерфейсы в Java (https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) или в C# (https://msdn.microsoft.com/en-us/library/ms173156.aspx).

//Это очень похоже на Java, когда интерфейсы используются, в тот момент, когда бы ты думал о множественном наследовании.
[source,pascal]
----
include::code-samples/interfaces_corba_test.lpr[]
----

### CORBA и COM интерфейсы

Почему интерфейсы названы "CORBA"?::

  Название *CORBA* крайне неудачное. Куда лучший термин был бы *чистый интерфейс*. Эти интерфейсы являются _"чистой особенностью языка"_. Их можно использовать если возникает необходимость typecast различные классы как один и тот же интерфейс, поскольку у них одинаковая API.
+
//The declaration `{$interface corba}` simply means that the declared interfaces *do not* automatically descend from the special `IUnknown` interface. Which in turn means that they *do not* by default have any extra baggage (like reference-counting found in the *COM* interfaces).
//+
При том, что эти интерфейсы могут использоваться вместе с _технологией CORBA (Common Object Request Broker Architecture)_ (см. https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture), они _не_ имеют к ней никакого отношения.

Требуется ли задавать `{$interfaces corba}` ?::

  Да, поскольку по умолчанию
//(if we would omit the `{$interfaces corba}` directive)
  будут созданы _COM интерфейсы_. Это же можно указать явно с помощью директивы `{$interfaces com}`, но не обязательно, так как это случай по умолчанию.
+
Лично я не советую использовать _COM интерфейсы_. Особенно в случае, если Вам знакомы интерфейсы из других языков программирования. _Интерфейсы CORBA_ в Паскале это именно то, что ожидается от интерфейсов, они идентичны интерфейсам в C# и Java. При этом _COM интерфейсы_ привносят дополнительные "особенности", которые скорее всего не понадобятся.
+
Обратите внимание, что `{$interfaces xxx}` определяет только интерфейсы, родительский интерфейс которых явно не указан (лишь используется ключевое слово `interface`, а не `interface(ISomeAncestor)`). Если интерфейс имеет родительский интерфейс, он имеет такой же тип, как и родительский интерфейс и не зависит от директивы `{$interfaces xxx}`.

Что такое COM интерфейсы?::

  Понятие _COM интерфейс_ является синонимом понятия _интерфейс, наследующий некоторый интерфейс_ `IUnknown`. Такое наследование от `IUnknown` означает:
+
* Требует, чтобы классы определяли методы `_AddRef` и `_ReleaseRef`. Правильная имплементация этих методов позволит управлять объектом с помощью подсчёта ссылок (reference-counting).
* Добавляет метод `QueryInterface`.
* Позволяет взаимодействовать с технологией _COM (Компонентная модель объектов)_.

Почему я не советую использовать COM интерфейсы?::

  Дополнительные возможности, привнесённые COM интерфейсами с моей точки зрения проблематичны. Не поймите превратно -- идея reference-counting очень хороша. Однако переплетать такой функционал с интерфейсами (вместо того, чтобы делать их "поперечными" свойствами) на мой взгляд является очень грязным. И явно не соответствует задачам, которые я встречал.
+
--
* Иногда возникает необходимость передать обычные классы (не имеющими ничего общего) через обычный интерфейс.
* Иногда возникает желание управлять памятью с помощью технологии reference counting.
* _Возможно_ когда-нибудь лично мне тоже пригодится _COM технология_.
--
+
Но всё это - ничем не связанные задачи. Переплетать их в единой особенности языка, лично на мой взгляд, нехорошо. И это не просто вопрос эстетики, такой подход причиняет реальные проблемы: механизм reference-counting интерфейса COM, даже если отключён с помощью специальных имплементаций `_AddRef` и `_ReleaseRef`, всё равно может привести к ошибкам. Придётся быть внимательным и следить, чтобы нигде не осталась временная ссылка на интерфейс, после освобождения экземпляра класса. Чуть подробнее речь об этом пойдёт дальше.
+
Именно по этому, лично мой совет: всегда использовать интерфейс в стиле _CORBA_ и соответствующую `{$interfaces corba}` директиву в современном коде, который работает с интерфейсами. На мой взгляд, _COM_ интерфейсы это некоторое _недоразумение языка_.
+
Однако, чтобы быть честными, чуть дальше будет детально идти речь о _COM интерфейсах_.

Можно ли использовать reference-counting совместно с интерфейсом CORBA?::

  Естественно. Необходимо лишь добавить методы `_AddRef` / `_ReleaseRef`. Нет необходимости наследовать интерфейс `IUnknown`. Впрочем, в большинстве случаев, если возникает необходимость использовать reference-counting в интерфейсах, можно просто использовать COM интерфесы.
//    Stress that non reference counted interfaces are more "bare" and deemphasize the link to corba and java. Note that iunknown doesn't just do refcounting though, it also plays a part in identity (queryinterface) that allows to get other interfaces supported by the object from the object. (e.g. to see if you can "upcast" an interface to a newer version)
//  Roger. The way I understand, the better names would be "always-descend-from-IUnknown" vs "don't-always-descend-from-iUnknown", not "COM" vs "CORBA". That would certainly be clearer for someone who is not interested in interacting with outside services (neither COM nor CORBA) and just wants a language feature (with the purpose of casting two classes to a common interface, because they share a common API, similar to interfaces in Java/C#).

### GUID-ы интерфейсов

GUID-ы это на первый взгляд случайная последовательность букв и цифр `['{ABCD1234-...}']` которую можно увидеть при каждом объявлении интерфейса. В действительности они и являются случайными. И, к сожалению, в них есть необходимость.

//Yes, they look ugly.
//, and I wish they would not be necessary.
В них не вкладывается никакого смысла (если не планируется интеграция с технологиями _COM_ или _CORBA_). Однако для исполнения программы они обязательны. И пусть не сбивает с толку компиллятор, который, увы, позволяет создавать интерфейсы без GUID-ов.

Без присваивания (уникального) GUID-а, все интерфейсы будут идентичными для оператора `is`. Таким образом, он всегда будет возвращать `true` если данный класс поддерживает _любой_ из используемых интерфейсов. Волшебная функция `Supports(ObjectInstance, IMyInterface)` работает несколько лучше в данном случае, поскольку выдаст ошибку компилляции для интерфейсов без GUID. Это касается CORBA и COM интерфейсов, для версии FPC 3.0.0.

Таким образом, необходимо обязательно объявлять GUID для каждого интерфейса. Можно использовать встроенный генератор GUID-ов _Lazarus GUID generator_ (горячая клавиша `Ctrl + Shift + G` в режиме редактирования). Или воспользоваться он-лайн сервисом, например https://www.guidgenerator.com/ .

А можно вообще написать свой инструмент, использующий `CreateGUID` и `GUIDToString` функции в RTL. Например таким образом:

[source,pascal]
----
include::code-samples/gen_guid.lpr[]
----

### Уродливые (COM) интерфейсы

Используя _COM интерфейсы_ даёт две дополнительных возможности:

. интеграция с технологией COM (технология, использующаяся в Windows, также доступна в Unix-системах через _XPCOM_, который используется Mozilla),
. подсчёт ссылок - reference counting (что позволяет автоматически уничтожать ???интерфейс, когда количество все ссылки на интерфейс уходят из поля переменных).

Лично на мой взгляд это крайне неправильно переплетать _интерфейсы_ с такими возможностями. Это усложняет использование интерфейсов для того, для чего они предназначены: когда у многих классов один и тот же API, однако они не могут происходить от одного родительского класса. Используя же _COM интерфейс_, следует помнить о механизме _автоматического уничтожения_ и его отношении к технологии COM.

На практике это означает следующее:

// +
// The relation to COM technology has . The reference counting idea is baffling. Why would you connect one language feature, _interfaces_, with something so unrelated like _reference counting_? It seems, because the COM technology required it...

* В классе необходимо создать магические методы `_AddRef`, `_Release` и `QueryInterface`. Или наследовать класс, который уже имеет их. Конкретная имплеметация этих методов позволяет включить или отключить такую возможность COM интерфейсов, как __reference-counting__. Впрочем, отключать её достаточно опасно -- см. следующий подраздел.

** Стандартный класс `TInterfacedObject` имеет эти методы выполненными в таком виде, чтобы _включить_ reference-counting.
** Стандартный класс `TComponent` имеет эти методы выполненными в таком виде, чтобы _выключить_ reference-counting. В *Castle Game Engine* предоставлены дополнительные классы, от которых можно выполнять наследование: `TNonRefCountedInterfacedObject` и `TNonRefCountedInterfacedPersistent` для этих целей, см. детальнее://github.com/castle-engine/castle-engine/blob/master/src/base/castleinterfaces.pas .

//* You can turn off the reference-counting mechanism by simple `_AddRef`, `_Release` implementations that always return `-1`. Actually, the standard implementation of these methods in `TComponent`, `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent` already does this for you.

* Необходимо быть аккуратным при освобождении класса, когда на него могут ссылаться некоторые переменные интерфейса. Поскольку интерфейсы освобождаются с помощью виртуального метода (потому что он _может использовать reference-counting, даже если_ `_AddRef` _написан таким образом, чтобы отключить эту возможность_), то нельзя освобождать низлежащий экземпляр объекта из-за того, что какая-либо интерфейсная переменная может на него указывать. См. раздел _"7.7 Reference counting"_ в руководстве FPC (http://freepascal.org/docs-html/ref/refse47.html).
//, http://bugs.freepascal.org/view.php?id=10374 .

Чтобы безопасно использовать _COM интерфейсы_ необходимо

* осознавать факт, что в них используется reference-counting,
* наследовать соответствующие классы от `TInterfacedObject`,
* и избегать прямого обращения к экземпляру класса, вместо чего всегда использовать экземпляр через интерфейс, оставляя алгоритму reference-counting управлять освобождением памяти.

Ниже представлен пример использования такого интерфейса:

[source,pascal]
----
include::code-samples/interfaces_com_with_ref_counting.lpr[]
----

### Использование COM интерфейсов с отключённым reference-counting

As mentioned in the previous section, your class can descend from `TComponent` (or a similar class like `TNonRefCountedInterfacedObject` and `TNonRefCountedInterfacedPersistent`) which disables reference-counting for COM interfaces. This allows you to use COM interfaces, and still free the class instance manually.

You need to be careful in this case to not free the class instance when some interface variable may refer to it. Remember that every typecast `Cx as IMyInterface` also creates a temporary interface variable, which may be present even until the end of the current procedure. For this reason, the example below uses a `UseInterfaces` procedure, and it frees the class instances _outside_ of this procedure (when we can be sure that temporary interface variables are out of scope).

To avoid this mess, it's usually better to use CORBA interfaces, if you don't want reference-counting with your interfaces.

[source,pascal]
----
include::code-samples/interfaces_com_test.lpr[]
----

### Typecast интерфейсов без оператора "as"

Этор раздел касается как _CORBA_, так и _COM_ интерфейсов.

Casting to an interface type using the `as` operator makes a check at run-time. Consider this code:

[source,pascal]
----
UseThroughInterface(Cx as IMyInterface);
----

It works for all `C1`, `C2`, `C3` instances in the examples in previous sections. If executed, it would make a run-time error in case of `C3`, that does not implement `IMyInterface` (but we avoid the error by checking `Cx is IMyInterface` before doing the cast).

You can instead cast the instance as an interface implicitly:

[source,pascal]
----
UseThroughInterface(Cx);
----

In this case, the typecast must be valid at compile-time. So this will compile for `C1` and `C2` (that are declared as classes that implement `IMyInterface`).

But it will not compile for `C3`.

In essence, this typecast looks and works just like for regular classes. Wherever an instance of a class `TMyClass` is required, you can always use there a variable that is declared with a class of `TMyClass`, *or `TMyClass` descendant*. The same rule applies to interfaces. No need for any explicit typecast in such situations.

An equivalent is also

[source,pascal]
----
UseThroughInterface(IMyInterface(Cx));
----

This is also a typecast that must be valid at compile-time. Note that this syntax is inconsistent with classes typecasts. In case of classes, writing `TMyClass\(C)` is an _unsafe, unchecked_ typecast. In case of interfaces, writing `IMyInterface\(C)` is a safe, fast (checked at compile-time) typecast.

## Про этот документ

Copyright Michalis Kamburelis.

Исходные файлы этого документа в формате AsciiDoc можно скачать по адресу: https://github.com/michaliskambi/modern-pascal-introduction .
Автор будет рад любым пожеланиям, исправлениям, расширениям материала, доработкам и pull request-ам :). С автором можно связаться через профиль GitHub либо по e-mail: michalis.kambi@gmail.com . Домашняя страничка автора: https://michalis.ii.uni.wroc.pl/~michalis/ .

Этот документ можно свободно распространять и изменять на лицензи идентичной лицензии Wikipedia https://en.wikipedia.org/wiki/Wikipedia:Copyrights :

* _Creative Commons Attribution-ShareAlike 3.0 Unported License (CC BY-SA)_
* Либо _GNU Free Documentation License (GFDL) (unversioned, with no invariant sections, front-cover texts, or back-cover texts)_ .

Благодарю за прочтение!

Перевод на русский выполнен:
Александр Скворцов и Евгений Лоза
2016-2017.
